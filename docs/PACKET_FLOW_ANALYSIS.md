# üîç An√°lise do Fluxo de Pacotes - Albion Sniffer

## üìã **Vis√£o Geral**

Este documento analisa o **fluxo completo** de processamento de pacotes no Albion Sniffer, desde a **intercepta√ß√£o** na rede at√© o **mapeamento de offsets** e **gera√ß√£o de eventos**. O objetivo √© identificar os **pontos ideais** para intercepta√ß√£o e envio de dados para filas de descoberta.

## üîÑ **Fluxo Completo de Processamento**

### **1. Intercepta√ß√£o de Pacotes UDP**
```
üåê Rede (Porta 5050)
    ‚Üì
üì° PacketCaptureService.Device_OnPacketArrival()
    ‚Üì
üîß ExtractUdpPacket() - Extrai UDP de qualquer estrutura
    ‚Üì
üì¶ ProcessUdpPacket() - Processa payload UDP
    ‚Üì
üöÄ OnUdpPayloadCaptured event disparado
```

**Localiza√ß√£o:** `src/AlbionOnlineSniffer.Capture/PacketCaptureService.cs:120-140`

**C√≥digo Chave:**
```csharp
private void Device_OnPacketArrival(object sender, PacketCapture e)
{
    var rawPacket = e.GetPacket();
    var packet = Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
    
    var udpPacket = ExtractUdpPacket(packet);
    if (udpPacket != null)
    {
        ProcessUdpPacket(udpPacket); // ‚úÖ PONTO DE INTERCEPTA√á√ÉO 1
    }
}

private void ProcessUdpPacket(UdpPacket udpPacket)
{
    var payload = udpPacket.PayloadData;
    if (payload != null && payload.Length > 0)
    {
        // ‚úÖ PONTO DE INTERCEPTA√á√ÉO 2 - Payload UDP bruto
        OnUdpPayloadCaptured?.Invoke(payload);
    }
}
```

### **2. Pipeline de Captura**
```
üöÄ OnUdpPayloadCaptured event
    ‚Üì
üîß CapturePipeline.OnPacket()
    ‚Üì
üîß Protocol16Deserializer.ReceivePacket()
    ‚Üì
üåê IPhotonReceiver.ReceivePacket() (Albion.Network)
```

**Localiza√ß√£o:** `src/AlbionOnlineSniffer.App/Services/CapturePipeline.cs:50-60`

**C√≥digo Chave:**
```csharp
private void OnPacket(byte[] packetData)
{
    try
    {
        _logger.LogInformation("üì° PACOTE UDP CAPTURADO: {Length} bytes", packetData?.Length ?? 0);
        // ‚úÖ PONTO DE INTERCEPTA√á√ÉO 3 - Antes do parsing
        _deserializer.ReceivePacket(packetData);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Erro ao processar pacote UDP");
    }
}
```

### **3. Deserializa√ß√£o do Protocolo**
```
üåê IPhotonReceiver.ReceivePacket()
    ‚Üì
üîß Albion.Network.ReceiverBuilder
    ‚Üì
üéÆ Handlers espec√≠ficos processam o pacote
    ‚Üì
‚ú® Eventos do jogo s√£o criados
```

**Localiza√ß√£o:** `src/AlbionOnlineSniffer.Core/Services/Protocol16Deserializer.cs:30-40`

**C√≥digo Chave:**
```csharp
public void ReceivePacket(byte[] payload)
{
    try
    {
        _logger.LogDebug("Recebendo pacote UDP de {PayloadLength} bytes", payload.Length);
        
        // ‚úÖ PONTO DE INTERCEPTA√á√ÉO 4 - Antes do Albion.Network
        _photonReceiver.ReceivePacket(payload);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Erro ao processar pacote UDP: {Message}", ex.Message);
    }
}
```

### **4. Processamento por Handlers**
```
üéÆ Handler espec√≠fico (ex: NewCharacterEventHandler)
    ‚Üì
üîç Aplica√ß√£o de offsets aos par√¢metros
    ‚Üì
‚ú® Cria√ß√£o de eventos do jogo
    ‚Üì
üöÄ EventDispatcher.DispatchEvent()
```

**Localiza√ß√£o:** `src/AlbionOnlineSniffer.Core/Handlers/NewCharacterEventHandler.cs:50-80`

**C√≥digo Chave:**
```csharp
protected override async Task OnActionAsync(NewCharacterEvent value)
{
    // üîç OFFSETS APLICADOS AQUI - PONTO DE INTERCEPTA√á√ÉO 5
    // value.Id, value.Name, value.GuildName, etc. j√° foram extra√≠dos usando offsets
    
    // ‚úÖ PONTO DE INTERCEPTA√á√ÉO 6 - Evento criado com dados mapeados
    var playerSpottedV1 = new PlayerSpottedV1
    {
        EventId = Guid.NewGuid().ToString("n"),
        ObservedAt = DateTimeOffset.UtcNow,
        PlayerId = value.Id,        // ‚Üê Offset 0 aplicado
        PlayerName = value.Name,    // ‚Üê Offset 1 aplicado
        GuildName = value.GuildName, // ‚Üê Offset 2 aplicado
        // ... outros campos
    };
    
    // ‚úÖ PONTO DE INTERCEPTA√á√ÉO 7 - Antes do dispatch
    await eventDispatcher.DispatchEvent(playerSpottedV1);
}
```

### **5. Despacho de Eventos**
```
üöÄ EventDispatcher.DispatchEvent()
    ‚Üì
üìã Handlers espec√≠ficos por tipo
    ‚Üì
üåç Handlers globais
    ‚Üì
üì§ EventToQueueBridge (publica na fila)
```

**Localiza√ß√£o:** `src/AlbionOnlineSniffer.Core/Services/EventDispatcher.cs:50-80`

**C√≥digo Chave:**
```csharp
public async Task DispatchEvent(object gameEvent)
{
    try
    {
        var eventType = gameEvent.GetType().Name;
        
        // ‚úÖ PONTO DE INTERCEPTA√á√ÉO 8 - Evento sendo despachado
        
        // Handlers espec√≠ficos para o tipo de evento
        if (_eventHandlers.ContainsKey(eventType))
        {
            foreach (var handler in _eventHandlers[eventType])
            {
                tasks.Add(handler(gameEvent));
            }
        }
        
        // Handlers globais
        foreach (var handler in _globalHandlers)
        {
            tasks.Add(handler(gameEvent));
        }
        
        await Task.WhenAll(tasks);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Erro ao disparar evento: {EventType}", eventType);
    }
}
```

## üéØ **Pontos Ideais para Intercepta√ß√£o**

### **üî¥ PONTO 1: Payload UDP Bruto (Recomendado)**
**Localiza√ß√£o:** `PacketCaptureService.ProcessUdpPacket()`

**Vantagens:**
- ‚úÖ **Dados brutos** - Sem processamento
- ‚úÖ **Completo** - Todo o payload UDP
- ‚úÖ **Cedo no fluxo** - Antes de qualquer parsing
- ‚úÖ **Simples** - Apenas bytes

**Dados Dispon√≠veis:**
```json
{
    "EventName": "UDP_PAYLOAD_RAW",
    "Parameters": {
        "Payload": "bytes[]",
        "Length": "int",
        "SourcePort": "int",
        "DestinationPort": "int",
        "Timestamp": "DateTime"
    }
}
```

### **üü° PONTO 2: Antes do Parsing Albion.Network**
**Localiza√ß√£o:** `Protocol16Deserializer.ReceivePacket()`

**Vantagens:**
- ‚úÖ **Antes da descriptografia** - Dados ainda criptografados
- ‚úÖ **Payload completo** - Sem perda de dados
- ‚úÖ **F√°cil intercepta√ß√£o** - M√©todo simples

**Dados Dispon√≠veis:**
```json
{
    "EventName": "BEFORE_ALBION_NETWORK",
    "Parameters": {
        "Payload": "bytes[]",
        "Length": "int",
        "Timestamp": "DateTime"
    }
}
```

### **üü¢ PONTO 3: Evento com Offsets Aplicados**
**Localiza√ß√£o:** `NewCharacterEventHandler.OnActionAsync()`

**Vantagens:**
- ‚úÖ **Dados mapeados** - Offsets j√° aplicados
- ‚úÖ **Estruturado** - Objetos C# tipados
- ‚úÖ **Contexto completo** - Evento + dados

**Dados Dispon√≠veis:**
```json
{
    "EventName": "NewCharacterEvent",
    "Parameters": {
        "Id": "int",
        "Name": "string",
        "GuildName": "string",
        "AllianceName": "string",
        "PositionBytes": "bytes[]",
        "Items": "float[]"
    },
    "Offsets": [0, 1, 8, 51, 53, 16, 20, 22, 23, 40, 43],
    "Timestamp": "DateTime"
}
```

### **üîµ PONTO 4: Antes do Dispatch**
**Localiza√ß√£o:** `EventDispatcher.DispatchEvent()`

**Vantagens:**
- ‚úÖ **Evento final** - Dados processados
- ‚úÖ **Tipo conhecido** - Evento espec√≠fico
- ‚úÖ **Antes da distribui√ß√£o** - Controle total

## üöÄ **Implementa√ß√£o Recomendada**

### **Estrat√©gia 1: Intercepta√ß√£o no PacketCaptureService (PONTO 1)**

```csharp
// ‚úÖ MODIFICA√á√ÉO M√çNIMA - Adicionar evento
public class PacketCaptureService : IPacketCaptureService
{
    // ‚úÖ NOVO EVENTO para descoberta
    public event Action<DiscoveryPacketData>? OnDiscoveryPacketCaptured;
    
    private void ProcessUdpPacket(UdpPacket udpPacket)
    {
        var payload = udpPacket.PayloadData;
        if (payload != null && payload.Length > 0)
        {
            // ‚úÖ INTERCEPTA√á√ÉO PARA DESCOBERTA
            var discoveryData = new DiscoveryPacketData
            {
                EventName = "UDP_PAYLOAD_RAW",
                Parameters = new Dictionary<string, object>
                {
                    ["Payload"] = payload,
                    ["Length"] = payload.Length,
                    ["SourcePort"] = udpPacket.SourcePort,
                    ["DestinationPort"] = udpPacket.DestinationPort,
                    ["Timestamp"] = DateTime.UtcNow
                }
            };
            
            OnDiscoveryPacketCaptured?.Invoke(discoveryData);
            
            // Fluxo normal continua
            OnUdpPayloadCaptured?.Invoke(payload);
        }
    }
}

// ‚úÖ NOVO MODELO para dados de descoberta
public class DiscoveryPacketData
{
    public string EventName { get; set; } = string.Empty;
    public Dictionary<string, object> Parameters { get; set; } = new();
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
}
```

### **Estrat√©gia 2: Intercepta√ß√£o no EventDispatcher (PONTO 4)**

```csharp
// ‚úÖ MODIFICA√á√ÉO M√çNIMA - Adicionar evento
public class EventDispatcher
{
    // ‚úÖ NOVO EVENTO para descoberta
    public event Action<DiscoveryEventData>? OnDiscoveryEventDispatched;
    
    public async Task DispatchEvent(object gameEvent)
    {
        try
        {
            var eventType = gameEvent.GetType().Name;
            
            // ‚úÖ INTERCEPTA√á√ÉO PARA DESCOBERTA
            var discoveryData = new DiscoveryEventData
            {
                EventName = eventType,
                Parameters = ExtractEventParameters(gameEvent),
                Timestamp = DateTime.UtcNow
            };
            
            OnDiscoveryEventDispatched?.Invoke(discoveryData);
            
            // Fluxo normal continua
            // ... resto do c√≥digo
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Erro ao disparar evento: {EventType}", eventType);
        }
    }
    
    private Dictionary<string, object> ExtractEventParameters(object gameEvent)
    {
        // Extrair propriedades do evento via reflection
        var parameters = new Dictionary<string, object>();
        var properties = gameEvent.GetType().GetProperties();
        
        foreach (var prop in properties)
        {
            try
            {
                var value = prop.GetValue(gameEvent);
                parameters[prop.Name] = value ?? "null";
            }
            catch
            {
                parameters[prop.Name] = "error";
            }
        }
        
        return parameters;
    }
}

// ‚úÖ NOVO MODELO para dados de descoberta
public class DiscoveryEventData
{
    public string EventName { get; set; } = string.Empty;
    public Dictionary<string, object> Parameters { get; set; } = new();
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
}
```

## üìä **Compara√ß√£o das Estrat√©gias**

| Crit√©rio | PONTO 1 (UDP Bruto) | PONTO 2 (Antes Albion.Network) | PONTO 3 (Offsets Aplicados) | PONTO 4 (Antes Dispatch) |
|----------|---------------------|--------------------------------|------------------------------|---------------------------|
| **Dados** | ‚úÖ Completos | ‚úÖ Completos | ‚úÖ Mapeados | ‚úÖ Processados |
| **Complexidade** | üü¢ Baixa | üü¢ Baixa | üü° M√©dia | üü° M√©dia |
| **Timing** | üü¢ Muito cedo | üü° Cedo | üü° M√©dio | üî¥ Tarde |
| **Criptografia** | ‚úÖ Preservada | ‚úÖ Preservada | ‚ùå Descriptografada | ‚ùå Descriptografada |
| **Estrutura** | ‚ùå Bruta | ‚ùå Bruta | ‚úÖ Estruturada | ‚úÖ Estruturada |
| **Offsets** | ‚ùå N√£o aplicados | ‚ùå N√£o aplicados | ‚úÖ Aplicados | ‚úÖ Aplicados |

## üéØ **Recomenda√ß√£o Final**

### **üü¢ PONTO 1 (UDP Bruto) - RECOMENDADO**

**Justificativa:**
1. **Dados completos** - Sem perda de informa√ß√£o
2. **Criptografia preservada** - Dados originais
3. **Implementa√ß√£o simples** - M√≠nima modifica√ß√£o
4. **Flexibilidade m√°xima** - Permite qualquer tipo de an√°lise

**Implementa√ß√£o:**
```csharp
// 1. Adicionar evento no PacketCaptureService
public event Action<DiscoveryPacketData>? OnDiscoveryPacketCaptured;

// 2. Conectar ao sistema de filas
_capture.OnDiscoveryPacketCaptured += async (discoveryData) =>
{
    await _discoveryQueue.PublishAsync("albion.discovery.raw", discoveryData);
};

// 3. Dados enviados para fila
{
    "EventName": "UDP_PAYLOAD_RAW",
    "Parameters": {
        "Payload": "bytes[]",
        "Length": "int",
        "Timestamp": "DateTime"
    }
}
```

### **üü° PONTO 4 (Antes Dispatch) - ALTERNATIVA**

**Justificativa:**
1. **Dados processados** - Estruturados e tipados
2. **Offsets aplicados** - Mapeamento completo
3. **Contexto rico** - Eventos espec√≠ficos do jogo

**Implementa√ß√£o:**
```csharp
// 1. Adicionar evento no EventDispatcher
public event Action<DiscoveryEventData>? OnDiscoveryEventDispatched;

// 2. Conectar ao sistema de filas
_eventDispatcher.OnDiscoveryEventDispatched += async (discoveryData) =>
{
    await _discoveryQueue.PublishAsync("albion.discovery.events", discoveryData);
};

// 3. Dados enviados para fila
{
    "EventName": "NewCharacterEvent",
    "Parameters": {
        "Id": "int",
        "Name": "string",
        "GuildName": "string"
    },
    "Offsets": [0, 1, 8, 51, 53, 16, 20, 22, 23, 40, 43]
}
```

## üìù **Conclus√£o**

O **PONTO 1 (UDP Bruto)** √© a **melhor op√ß√£o** para intercepta√ß√£o e envio para filas de descoberta porque:

- ‚úÖ **Preserva dados originais** - Sem perda de informa√ß√£o
- ‚úÖ **Implementa√ß√£o simples** - M√≠nima modifica√ß√£o no c√≥digo
- ‚úÖ **Flexibilidade m√°xima** - Permite qualquer tipo de an√°lise
- ‚úÖ **Criptografia preservada** - Dados exatamente como recebidos
- ‚úÖ **Performance** - Sem overhead de processamento

Com essa abordagem, voc√™ pode implementar um sistema de descoberta que:
1. **Captura** todos os pacotes UDP brutos
2. **Envia** para fila `albion.discovery.raw`
3. **Processa** em projeto separado para an√°lise
4. **Descobre** novos offsets automaticamente
5. **Gera** configura√ß√µes atualizadas

O sistema atual j√° est√° bem estruturado para essa intercepta√ß√£o, requerendo apenas a adi√ß√£o de um evento adicional no `PacketCaptureService`.
